Переменные
Определение
переменной
Переменная - именованная
область
памяти, адрес
которой
можно
использовать
для
осуществления
доступа
к
данным.Данные, находящиеся
в
переменной(то
есть
по
данному
адресу
памяти), называются
значением
этой
переменной.Если
тип
данных
определяется
на
этапе
компиляции, имеет
место
статическая
типизация, а
если
на
этапе
выполнения
программы - динамическая.

В
Python
используется
динамическая
типизация!!!

Особенности
объявления
переменных
в
Python
Можно
объявить
произвольное
количество
переменных(в
пределах
размера
ОЗУ).Главное
придумать
им
имена
и
присвоить
начальные
значения.

Можно
использовать
любые
имена
кроме
зарезервированных

Есть
рекомендации
по
написанию
имен
переменных - это
официальная
рекомендация
PEP
8 - - Style
Guide
for Python Code

Стиль
для
именования
переменных
называется «Snake
case».

сamelCase
snake_case
PascalCase
kebab - case

зарезервированные
имена
Python
import keyword

print(keyword.kwlist)
Как
объявить
переменную
в
Python
age = 35  # в age указатель на область памяти, где лежит 35
print(id(age))
print(id(35))
y = 35
print(id(y))
z = y
print(id(z))
print(id(256))
print(id(257))
next_number = 257
print(id(next_number))
print(id(234567))
my_name = "Oleg"
print(my_name)

print(id(my_name))
print(id('Oleg'))
oleg = 36
print(id(oleg))
print(my_name)
x = 10
y = 20
x, y = y, x
print('x:', x, 'y:', y)
my_name
и
My_name - это
разные
переменные !
%%html
< style >
table
{float: left}
table
th, table
td
{text - align: center !important;
font - size: 150 %;}
< / style >
Список
встроенных
типов
в
Python
Type
Название
Тип
данных
Пример
Number
Число
Неизменяемый
123, 0.5, 1 + 2j, Decimal(), Fraction()
String
Строка
Неизменяемый
"Hello world", 'Hello'
List
Список
Изменяемый[1, 4, 5]
Dictionary
Словарь
Изменяемый
{1: "one", 2: "two"}
Tuple
Кортеж
Неизменяемый(1, 4, 5)
File
Файл
Изменяемый
open("a.txt")
Set
Множество
Изменяемый
{1, 4, 5, 6, 7}
Как
узнать
тип
данных?
print(type(my_name))
print(type(age))
print(type('name'))
print(type(2))
print(type(2.6))
Числовые
типы
данных
в
Python
Целые
числа — числа, используемые
для
представления
целочисленного
количества
предметов.Т.е.у
них
нет
дробной
части.В
Python
представлены
типом
int.Могут
содержать
произвольное
количество
знаков(в
пределах
размера
ОЗУ)

Основные
арифметические
действия
с
числами
в
Python
Вид
оператора
Его
математический
эквивалент
+    Операция
сложения
-    Операция
вычитания
*Операция
умножения
/ Операция
деления
// Деление
с
округлением
до
минимального
целого
%Остаток
от
деления
()
Изменение
приоритета
операций
** Возведение
в
степень
Приоритет
арифметических
операторов
в
Python
такой
же, как
и
в
математике!!!

11 / 3
print(11 // 3)
print(11 % 3)
3.6666666666666665 * 3
3 * (11 // 3) + (11 % 3)
x, y = divmod(11, 3)
print(x, y)
print(divmod(11, 3))
print(-11 // 3)  # До ближайшего наименьшего целого!
print(-11 / 3)
print(-11 % 3)
3 * (-11 // 3) + (-11 % 3)
divmod(-11, 3)
divmod(-13, 3)  # ?
-13 // 3
212_324_325_636_57485697987983 % 9  # 0, 1, 2, 3, 4, 5, 6, 7, 8
21232432563657485697987984 // 9
# Важно!!! Все переменные должны быть объявлены до того, как они используются.
a = 5
c = a + b * 3
b = 10
print(c)
# если имя переменной встречается и справа, и слева от оператора равно,
# это означает, что новое значение переменной слева, вычисляется на
# основании старого значения (справа от оператора = )
age = 353
age1 = age
print(id(age1))
age = age + 1
print(age)
print(id(age))
print(age1)
print(id(age1))
age = 35
age += 1
print(age)
Задача
Дано
4 - х
значное
число.Нужно
"разбить"
это
число
по
середине.

x = 100
digit = 7254
left, right = divmod(digit, x)
print(left, right)
left, right = divmod(digit, 1)
print(left, right)
left, right = divmod(digit, 1000)
print(left, right)
age = 35
age *= 3
print(age)
number = 3847
print(number // 10)
print(number % 10)

first_number = number % 10
number = number // 10
second_number = number % 10
print(second_number, first_number)
Системы
счисления
Десятичные
числа

Обычно
мы
записываем
числа, используя
так
называемую
десятичную
позиционную
систему
счисления.

# 279
2 * 10 ** 2 + 7 * 10 ** 1 + 9 * 10 ** 0
Это
десятичная
система, или
система
с
основанием
10, и
поэтому
каждая
позиция – это
степень
десяти;
другими
словами, 10
умножается
на
себя
определенное
количество
раз.Самая
правая
позиция – это
10, возведенное
в
степень
0, что
равно
1, так
как
любое
число, возведенное
в
степень
0, равно
1.
Следующая
позиция – это
10, возведенное
в
степень
1, что
равно
10, а
еще
следующее
место – это
10, возведенное
в
степень
2(10 × 10), что
равно
100.

Если
бы
нам
нужно
было
представить
число
больше
999
в
десятичной
системе, мы
бы
добавили
еще
одну
позицию
слева, позицию
тысяч, и
вес
этой
позиции
был
бы
равен
10
в
степени
3(10 × 10 × 10), т.е.
1000.

По
такой
схеме
мы
можем
представить
любое
большое
целое
число, добавляя
по
мере
необходимости
новые
позиции.

Двоичные
числа

Система
счисления, состоящая
только
из
двух
цифр, – это
система
с
основанием
2, или
двоичная
система.Двоичная
система
по - прежнему
является
позиционной
системой
счисления, поэтому
фундаментальная
техника
такая
же, как
и
у
десятичной
системы, но
есть
несколько
изменений.Во - первых, каждая
позиция
представляет
собой
степень
2, а
не
степень
10.
Во - вторых, на
каждой
позиции
может
быть
только
одна
из
двух
цифр(0
или
1), а
не
один
из
десяти.

Ниже
приведен
пример
представления
числа
5
в
двоичной
системе
счисления.

print((1 * 2 ** 2) + (0 * 2 ** 1) + (1 * 2 ** 0))  # 101 в двоичной системе
(1 * 2 ** 2) + (0 * 2 ** 1) + (1 * 2 ** 0)
Как
и
в
десятичной
системе
счисления, каждая
позиция
имеет
вес, равный
основанию, возведенному
в
различные
степени.Так
как
у
нас
основание
2, самая
правая
позиция – это
2
в
степени
0, т.е.
1.
Следующая
позиция – это
2
в
степени
1, т.е.
2, и
еще
следующая
позиция – это
2, возведенное
в
степень
2(2 × 2), т.е.
4.
Так
же
как
и
в
десятичной
систе - ме, для
получения
общего
значения
мы
умножаем
символ
в
каждой
позиции
на
вес
позиции
и
суммируем
результаты.

Биты
и
байты

Каждый
бит
может
быть
либо
0, либо
1.
Один
бит
не
может
передать
много
информации;
он
выключен
либо
включен, 0
или
1.
Для
представления
чего - либо
более
сложного
нам
нужна
последовательность
битов.Чтобы
облегчить
работу
с
этими
последовательностями
битов, компьютеры
объединяют
биты
в
наборы
по
восемь
штук, называемые
байтами.

Так
сколько
же
данных
мы
можем
хранить
в
байте? Другой
способ
посмотреть
на
этот
вопрос – это
найти, сколько
уникальных
комбинаций
из
нулей
и
единиц
мы
можем
сделать
с
помощью
наших
8
бит?

2 ** 8  # 256 комбинаций
2 ** 16
2 ** 32
2 ** 64
tera
1
0
99
511
627
776 = > 2 ** 40

giga
1
073
741
824 = > 2 ** 30

mega
1
04
8
576 = > 2 ** 20

kilo
1
024 = > 2 ** 10

Шестнадцатеричная
система

Наша «обычная» система
счисления – десятичная, или
с
основанием
10.
Компьютеры
используют
двоичную
систему
счисления, или
с
основанием
2.
Шестнадцатеричная – это
система
с
основанием
16!

Шестнадцатеричная
система
счисления – это
позиционная
система
счисления, в
которой
каждая
позиция
представляет
собой
степень
шестнадцати
и
на
каждой
позиции
может
быть
один
из
шестнадцати
символов.

Как
и
во
всех
позиционных
системах
счисления, крайняя
правая
позиция
по - прежнему
будет
позицией
единиц.Следующая
позиция
слева
будет
позицией
16, затем
позиция
256(16 × 16), затем – 4
0
96(16 × 16 × 16) и
т.д.Достаточно
просто.Обычно
мы
используем
десять
символов
для
представления
чисел, от
0
до
9.
Нам
нужно
добавить
еще
шесть
символов
для
представления
других
значений.Мы
могли
бы
выбрать
несколько
случайных
символов, например &


@  # , но эти символы не имеют очевидного порядка. Вместо этого стандартом является использование A, B, C, D, E и F (прописные или строчные – неважно!). В этой схеме A обозначает 10, B – 11 и т. д., вплоть до F, которая обозначает 15. Это имеет смысл, так как нам нужны символы, которые представляют значения от нуля до значения основания за вычетом единицы. Поэтому наши дополнительные символы – это буквы от A до F. Стандартной практикой является использование префикса 0x для обозначения шестнадцатеричной системы, когда это необходимо подчеркнуть.


Хранение
данных
внутри
компьютера - набор
16 - ных
чисел
0
F
00
FF
10

(0 * 16 ** 3) + (1 * 16 ** 2) + (10 * 16 ** 1) + (5 * 16 ** 0)  # 01 A5(hex) => 421(decimal)
В
компьютере
используется
двоичный
код, поэтому
число
19
в
двоичной
системе
счисления, будет
выглядеть
как
10011.
Также
иногда
нужно
переводить
числа
из
одной
системы
счисления
в
другую.Python
для
этого
предоставляет
несколько
функций:

int([object], [основание системы счисления]) - преобразование
к
целому
числу
в
десятичной
системе
счисления.По
умолчанию
система
счисления
десятичная, но
можно
задать
любое
основание
от
2
до
36
включительно.

bin(x) - преобразование
целого
числа
в
двоичную
строку.

hex(х) - преобразование
целого
числа
в
шестнадцатеричную
строку.

oct(х) - преобразование
целого
числа
в
восьмеричную
строку.

int('4')
4
int('4', 10)
4
int('11', 2)
3
int('11', 10)
11
int('10', 2)
2
int('z', 36)
35
int('10', 36)
36
int('F', 16)
int('10', 16)
# Error
int('4.5')
---------------------------------------------------------------------------
ValueError
Traceback(most
recent
call
last)
Cell
In[52], line
2
1  # Error
----> 2
int('4.5')

ValueError: invalid
literal
for int() with base 10: '4.5'
int(19.5)
19
int(19.999999)
19
print(bin(19))  # '0b10011'
print(oct(19))  # '0o23'
print(hex(19))  # '0x13'
print(int('10011', 2))  # 19
print(int('0b10011', 2))  # 19
0b10011
0o23
0x13
19
19
2 ** 1024
2 ** 1025
# Форматирование больших чисел
x = 10_000_000_000_000
print(x)
Вещественные
числа
в
Python
Главным
отличием
вещественных
чисел
от
целых
является
наличие
символа
"."
которая
отделяет
целую
часть
от
дробной:

2.78
2.0
2.
0.78
.78

В
Python
представлены
типом
float.Если
на
длину
целых
чисел
не
накладывается
абсолютно
никаких
ограничений
по
величине, то
с
вещественными
числами
это
не
так.Диапазон
возможных
значений[-1.8E308, 1.8E308].Также
нужно
знать, что
эти
переменные
обладают
точностью
только
до
16
знаков
после
запятой.

a = 2 ** 1025
b = a + 0.1
print(b)  # OverflowError: int too large to convert to float
---------------------------------------------------------------------------
OverflowError
Traceback(most
recent
call
last)
Cell
In[56], line
2
1
a = 2 ** 1025
----> 2
b = a + 0.1
3
print(b)  # OverflowError: int too large to convert to float

OverflowError: int
too
large
to
convert
to
float
Важно: числа
типа
float
не
являются
десятичными
дробями
и
используют
двоичную
арифметику
компьютера, поэтому
многие, даже
самые
простые
выражения
могут
вычисляться
с
ничтожно
малыми
погрешностями.Однако, из - за
этих
погрешностей, вполне
очевидные
операции
сравнения
работают
не
так
как
ожидается

0.1 + 0.1 + 0.1  # = 0.3?
0.30000000000000004
0.1 + 0.1
0.2
0.3 + 0.3 + 0.3
0.8999999999999999
ошибки
не
накапливаются
для
дробей
со
знаменателем
числа
по
степени
двойки - 2, 4, 8, 16
0.5 + 0.5 + 0.5
0.2399999999999999911182158029987476766109466552734375
0.25 + 0.25 + 0.25
0.75
0.125 + 0.125 + 0.125
0.375
z = 0.3 + 0.3 + 0.3
round(z, 3)
0.9
z = 0.3 + 0.3 + 0.3
round(z, 1)
0.9
round(4.5646546465465464, 3)
4.565
x = 1.5 * 4
print(x)
print(type(x))
6.0
<

class 'float'>


4 / 2
float.is_integer()
возвращает
True
если
дробная
часть
числа
равна
0
и
False
если
нет

res = x.is_integer()
print(res)
True
y = 5 / 2
y.is_integer()
False
6.0.is_integer()
True
6.
is_integer()  # error
<>:1: SyntaxWarning: invalid
decimal
literal
<>:1: SyntaxWarning: invalid
decimal
literal
/ var / folders / m0 / r_hwrnfj6yj7z69y8tl5swx80000gq / T / ipykernel_20926 / 826048409.
py: 1: SyntaxWarning: invalid
decimal
literal
6.
is_integer()  # error
Cell
In[76], line
1
6.
is_integer()  # error
^
SyntaxError: invalid
syntax
float.as_integer_ratio()
возвращает
пару
целых
чисел(кортеж), первое
из
которых
равно
числителю
а
второе
всегда
положительному
знаменателю
обыкновенной
дроби, значение
которой
точно
совпадает
с
указанным
исходным
числом
типа
float:

(0.3).as_integer_ratio()
(5404319552844595, 18014398509481984)
float('2.5')
2.5
float('2')
2.0
float(2)
2.0
Дополнительные
математические
методы
из
модуля
math
import math

a = 1
for method in dir(math):
    if not '__' in method:
        print(method, end='  *  ')
        a += 1
    if not a % 10:
        print()
acos * acosh * asin * asinh * atan * atan2 * atanh * cbrt * ceil *
comb * copysign * cos * cosh * degrees * dist * e * erf * erfc * exp *
exp2 * expm1 * fabs * factorial * floor * fmod * frexp * fsum * gamma * gcd *
hypot * inf * isclose * isfinite * isinf * isnan * isqrt * lcm * ldexp * lgamma *
log * log10 * log1p * log2 * modf * nan * nextafter * perm * pi * pow *
prod * radians * remainder * sin * sinh * sqrt * tan * tanh * tau * trunc *
ulp *
x = math.sqrt(7) * math.cos(math.pi * 3 / 4)
print(x)
-1.8708286933869707
Ввод
данных
с
клавиатуры
input('Type x: ')
'test'
x = input('Type x: ')
print(x)
1500
y = input('Type y: ')
print(x + y)
15003500
x + y
'15003500'
x = float(input('Type x: '))
y = float(input('Type y: '))
print(x + y)
1300.0
int(10.0)
10
x = int(input('Type int: '))
print(x)
---------------------------------------------------------------------------
ValueError
Traceback(most
recent
call
last)
Cell
In[101], line
1
----> 1
x = int(input('Type int: '))
2
print(x)

ValueError: invalid
literal
for int() with base 10: ''
# 54321
5 * 10000 + 4 * 1000 + 3 * 100 + 2 * 10 + 1 * 1
54321
l1 = [345] * 100000000
l2 = [10 ** 123] * 100000000
l3 = [47854875.8746] * 100000000
import time

start = time.time()
[x / 78 for x in l1]
print(time.time() - start)

start = time.time()
[x / 78 for x in l2]
print(time.time() - start)

start = time.time()
[x / 78 for x in l3]
print(time.time() - start)
3.04697585105896
5.135833978652954
3.0552468299865723
